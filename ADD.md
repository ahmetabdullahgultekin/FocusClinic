# Focus Clinic - Architecture Design Document (ADD)

## 1. Project Overview

**Project Name:** Focus Clinic
**Description:** A gamified productivity application designed for students preparing for difficult exams (e.g., DUS). It combines Pomodoro-style focus mechanics with RPG elements (managing a dental clinic) and a Token Economy system.
**Platform:** iOS & Android (via Kotlin Multiplatform & Compose Multiplatform).
**Core Philosophy:** "Productivity meets RPG." The user earns currency by focusing and spends it on real-life rewards (guilt-free breaks) or in-game upgrades (better clinic).
**Data Strategy:** Fully offline. All data is stored locally on-device. No cloud sync, no remote backend.

## 2. Technical Stack & Libraries

| Concern | Choice | Rationale |
|:---|:---|:---|
| Language | Kotlin (100% commonMain) | Single codebase for Android + iOS |
| UI Framework | Compose Multiplatform (Material 3) | Declarative, shared UI layer |
| Architecture Pattern | **MVI (Model-View-Intent)** | Unidirectional data flow; maps cleanly to session state machines (Idle -> Focusing -> Break -> Completed) |
| Dependency Injection | Koin | Native KMP support, lightweight |
| Navigation | **Decompose + Compose integration** | Lifecycle-aware, mature KMP support. Voyager is no longer actively maintained. |
| Local Database | **SQLDelight** | Fully multiplatform and stable. SQL-first approach generates type-safe Kotlin. Room KMP is still experimental. |
| Concurrency | Kotlin Coroutines & Flow | Standard KMP async primitives |
| Serialization | Kotlinx.Serialization | Multiplatform JSON/CBOR support |
| Date/Time | Kotlinx-datetime | Multiplatform date/time handling |
| Settings/KeyValue | Multiplatform Settings | Simple key-value preferences |

## 3. Architecture Layering (Clean Architecture)

The project strictly follows separation of concerns. Each layer is a **separate Gradle module** to enforce dependency rules at compile time.

```
:core:domain    -> Pure Kotlin, ZERO framework dependencies
:core:data      -> SQLDelight, repository implementations, mappers
:composeApp     -> UI, DI wiring, platform-specific adapters (expect/actual)
```

### A. Domain Layer — `:core:domain` (Pure Kotlin)

No dependencies on Android, iOS, SQLDelight, or any framework.

* **Entities:** Core business objects (`FocusSession`, `Clinic`, `UserProfile`, `Reward`, `ShopItem`).
* **Value Objects:** `Coin`, `ExperiencePoints`, `FocusDuration`, `Multiplier`.
* **Repository Interfaces (Ports):**
    * `FocusSessionRepository`
    * `UserProfileRepository`
    * `InventoryRepository`
    * `CustomRewardRepository`
    * `TransactionRepository`
* **Use Cases:**
    * `StartFocusSessionUseCase`
    * `CompleteFocusSessionUseCase` — calculates rewards using formulas and rules from Section 4.
    * `InterruptFocusSessionUseCase` — handles partial reward calculation.
    * `PurchaseShopItemUseCase` — deducts coins, adds item to inventory, records transaction.
    * `PurchaseCustomRewardUseCase` — deducts coins for real-life rewards, records transaction.
    * `UpgradeClinicUseCase`
    * `GetUserStatsUseCase` — aggregates profile, level, multipliers.
* **Domain Rules:** All reward formulas, multiplier caps, and minimum duration rules live here as constants/functions. No business logic in the data or presentation layer.

### B. Data Layer — `:core:data` (Implementation)

* **Data Source:** SQLDelight (local database).
* **DTOs:** Database entity classes generated by SQLDelight `.sq` files.
* **Repository Implementations:** Implement domain port interfaces.
* **Mappers:** DTO <-> Domain Entity converters (extension functions).

### C. Presentation Layer — `:composeApp` (UI + Platform)

* **Screens:** Composable functions per feature.
* **ViewModels (ScreenModels):** Process `Intent` -> produce `State` via `StateFlow`. Each screen has:
    * `XxxState` — immutable data class representing UI state.
    * `XxxIntent` — sealed interface of user actions.
    * `XxxViewModel` — reduces intents into state.
* **Platform Adapters (`expect/actual`):**
    * `LifecycleObserver` — detect app backgrounding (session interruption).
    * `WakeLockManager` — prevent screen sleep during focus sessions.
    * `NotificationManager` — timer completion and break reminders.
* **Navigation:** Decompose component tree with Compose integration.
* **DI:** Koin modules wiring all layers together.

## 4. Feature Specifications & Business Rules

### Feature 1: The Focus Engine

**Session Flow (State Machine):**
```
Idle -> Focusing -> Completed -> Break -> Idle
                 \-> Interrupted (app backgrounded)
                 \-> Cancelled (user manually stops)
```

**Duration Options:** User selects from predefined durations: `5, 10, 15, 25, 45, 60` minutes.

**Minimum Reward Threshold:** 5 minutes. Sessions under 5 minutes of actual focus earn nothing.

**Interruption Detection:** When the app goes to background (`onPause`), a grace period of **10 seconds** is allowed (e.g., accidental home button). Beyond that, the session is marked `INTERRUPTED`.

**Interrupted Session Rewards (Reduced Partial):**
```
earnedReward = (actualFocusedMinutes / plannedMinutes) * baseReward * 0.5
```
The 0.5 penalty multiplier discourages quitting but doesn't completely punish partial effort. If `actualFocusedMinutes < 5`, rewards are zero regardless.

**Visuals:** A "Patient" character sits in the dental chair. On completion, patient leaves happy. On interruption, patient leaves angrily.

**Platform Requirements:**
* **Android:** Foreground Service + WakeLock to prevent the OS from killing the timer. Notification channel for timer status.
* **iOS:** Background task registration. Local notification on timer completion.
* These are implemented via `expect/actual` declarations in `:composeApp`.

### Feature 2: RPG & Progression System

**XP Formula:**
```
XP = floor(FocusMinutes * 10 * ClinicMultiplier)
```

**Coin Formula:**
```
Coins = floor(FocusMinutes * 5 * EfficiencyMultiplier)
```

**Multiplier Cap:** All multipliers (ClinicMultiplier, EfficiencyMultiplier) are capped at **3.0x** maximum. This is enforced in the domain layer.

**Base Multiplier:** 1.0x (no items equipped).

**Level Thresholds:**

| Level | Title | Required Total XP |
|:---|:---|:---|
| 1 | Intern (Stajyer) | 0 |
| 2 | Assistant (Asistan) | 1,000 |
| 3 | Resident (Araştırma Görevlisi) | 3,000 |
| 5 | Specialist (Uzman) | 10,000 |
| 7 | Associate Professor (Doçent) | 25,000 |
| 10 | Professor (Profesör) | 60,000 |

**Clinic State:** The clinic has visual attributes stored in a `ClinicAttributes` value object:
* Wall color/theme
* Chair type
* Equipment set
* Decoration items

These attributes are derived from the user's `Inventory` — each purchased item maps to a visual change.

### Feature 3: Token Economy (The Shop)

**Virtual Shop (In-Game Items):**
Items that provide stat multipliers or visual upgrades.

| Example Item | Cost | Effect | Type |
|:---|:---|:---|:---|
| Ergonomic Chair | 500 | +10% XP (multiplier: 1.1) | EQUIPMENT |
| LED Lamp | 300 | +5% Coins (multiplier: 1.05) | EQUIPMENT |
| Wall Paint: Ocean | 200 | Visual only | DECORATION |
| Diploma Frame | 150 | Visual only | DECORATION |

* Multiplier effects from multiple items **stack additively** (e.g., 1.1 + 1.05 = 1.15 total bonus), NOT multiplicatively.
* Total multiplier is capped at 3.0x.

**Real-Life Reward Shop (User-Generated):**
* Full CRUD operations.
* User creates custom rewards: "Watch 1 episode" -> Cost: 300 Coins.
* Purchasing deducts coins and records a transaction.
* Soft-delete via `is_active` flag.

**Transaction Integrity:**
* Every coin earn/spend is recorded in the `Transactions` table.
* `UserProfile.current_coins` is the **derived balance** (sum of all transactions), NOT a manually incremented counter. This prevents desync.
* All purchase operations are atomic: deduct coins + add inventory/record reward in a single database transaction.

## 5. Data Model (SQLDelight Schema)

**Table: user_profile** (Singleton — always id = 1)

| Column | Type | Notes |
|:---|:---|:---|
| id | INTEGER | PK, always 1 |
| current_xp | INTEGER | Total accumulated XP |
| current_level | INTEGER | Derived from XP thresholds |
| title_rank | TEXT | e.g., "Intern" |
| created_at | INTEGER | Epoch millis |

*Note: `current_coins` is NOT stored here. It is computed from the `transactions` table.*

**Table: focus_sessions**

| Column | Type | Notes |
|:---|:---|:---|
| id | TEXT | PK (UUID string) |
| start_time | INTEGER | Epoch millis |
| end_time | INTEGER | Epoch millis, nullable (null if in progress) |
| planned_duration_minutes | INTEGER | Selected duration |
| actual_focus_minutes | INTEGER | Real focused time |
| status | TEXT | `COMPLETED`, `INTERRUPTED`, `CANCELLED` |
| earned_xp | INTEGER | XP awarded (0 if cancelled) |
| earned_coins | INTEGER | Coins awarded (0 if cancelled) |

**Table: inventory**

| Column | Type | Notes |
|:---|:---|:---|
| item_id | TEXT | PK |
| item_name | TEXT | Display name |
| item_type | TEXT | `DECORATION`, `EQUIPMENT` |
| modifier_type | TEXT | `XP_BONUS`, `COIN_BONUS`, `NONE` (nullable) |
| modifier_value | REAL | e.g., 0.1 for +10% bonus. 0.0 for decorations. |
| purchased_at | INTEGER | Epoch millis |

**Table: custom_rewards**

| Column | Type | Notes |
|:---|:---|:---|
| id | TEXT | PK (UUID string) |
| title | TEXT | "Drink Coffee" |
| cost | INTEGER | Coin price |
| is_active | INTEGER | 1 = active, 0 = soft-deleted |
| created_at | INTEGER | Epoch millis |

**Table: transactions** (Audit trail for the Token Economy)

| Column | Type | Notes |
|:---|:---|:---|
| id | TEXT | PK (UUID string) |
| type | TEXT | `EARN_FOCUS`, `SPEND_SHOP`, `SPEND_REWARD` |
| amount | INTEGER | Positive for earn, negative for spend |
| reference_id | TEXT | FK to focus_sessions.id or inventory.item_id or custom_rewards.id |
| description | TEXT | Human-readable: "Completed 25min session", "Purchased Ergonomic Chair" |
| created_at | INTEGER | Epoch millis |

**Derived Coin Balance Query:**
```sql
SELECT COALESCE(SUM(amount), 0) AS current_coins FROM transactions;
```

## 6. Project Directory Structure

```text
FocusClinic/
├── build.gradle.kts                  # Root build file
├── settings.gradle.kts               # Module declarations
│
├── core/
│   ├── domain/
│   │   ├── build.gradle.kts          # Pure Kotlin module, NO framework deps
│   │   └── src/commonMain/kotlin/
│   │       └── com/focusclinic/domain/
│   │           ├── model/            # Entities: FocusSession, UserProfile, ShopItem, Clinic
│   │           ├── valueobject/      # Coin, ExperiencePoints, FocusDuration, Multiplier
│   │           ├── repository/       # Port interfaces
│   │           ├── usecase/          # Business logic use cases
│   │           └── rule/             # Domain constants: XP thresholds, multiplier cap, formulas
│   │
│   └── data/
│       ├── build.gradle.kts          # Depends on :core:domain, SQLDelight
│       └── src/commonMain/
│           ├── kotlin/
│           │   └── com/focusclinic/data/
│           │       ├── repository/   # Repository implementations
│           │       └── mapper/       # DTO <-> Domain mappers
│           └── sqldelight/
│               └── com/focusclinic/data/
│                   └── database/     # .sq files defining tables and queries
│
├── composeApp/
│   ├── build.gradle.kts              # Depends on :core:domain, :core:data, Compose, Koin, Decompose
│   └── src/
│       ├── commonMain/kotlin/
│       │   └── com/focusclinic/app/
│       │       ├── presentation/
│       │       │   ├── theme/        # AppTheme, Colors, Typography
│       │       │   ├── components/   # Reusable Composables (CoinDisplay, TimerRing, PatientAvatar)
│       │       │   └── screens/
│       │       │       ├── focus/    # FocusScreen, FocusState, FocusIntent, FocusViewModel
│       │       │       ├── clinic/   # ClinicScreen — visual clinic based on inventory
│       │       │       ├── shop/     # ShopScreen — virtual items + custom rewards
│       │       │       └── stats/    # StatsScreen — session history, XP progress
│       │       ├── navigation/       # Decompose component tree, root component
│       │       └── di/              # Koin module definitions
│       │
│       ├── androidMain/kotlin/       # expect/actual: WakeLock, ForegroundService, Notifications
│       └── iosMain/kotlin/           # expect/actual: Background tasks, Local notifications
│
├── androidApp/                       # Android entry point (MainActivity, AndroidManifest)
└── iosApp/                           # iOS entry point (Xcode project)
```

## 7. UI/UX Guidelines

* **Theme:** Medical/Clean but Gamified. Primary palette: White, Teal (#009688), Soft Blue (#42A5F5).
* **Dark Mode:** Not in V1 scope. Design with Material 3 theming so it can be added later.
* **Placeholder Assets:**
    * `ic_tooth_coin` — Currency icon
    * `ic_patient_happy` — Session completed
    * `ic_patient_angry` — Session interrupted
    * `ic_clinic_default` — Base clinic visual
* **Animations:**
    * `AnimatedVisibility` for coin earn popups.
    * Scaling animation on coin counter when balance changes.
    * State-driven patient expressions (happy/angry) with crossfade.
* **Typography:** Material 3 defaults. No custom fonts in V1.

## 8. Testing Strategy

| Layer | Test Type | Tool | Coverage Target |
|:---|:---|:---|:---|
| `:core:domain` | Unit tests | kotlin.test | All use cases, reward formulas, level thresholds, multiplier cap logic |
| `:core:data` | Integration tests | SQLDelight in-memory driver | Repository implementations, transaction atomicity |
| `:composeApp` | UI tests | Compose UI testing | Critical flows: start session, purchase item, create reward |

**Test naming convention:** `methodName_WhenCondition_ShouldExpectedBehavior`

Example: `completeFocusSession_WhenDurationUnder5Minutes_ShouldReturnZeroRewards`

## 9. Implementation Steps

1. **Project Setup:** Initialize KMP project with Gradle modules (`:core:domain`, `:core:data`, `:composeApp`). Configure Koin, Decompose, SQLDelight.
2. **Domain Layer:** Define all entities, value objects, repository interfaces, and use cases in `:core:domain`. Implement reward formulas and business rules. Write unit tests.
3. **Data Layer:** Define SQLDelight `.sq` schema files. Implement repository adapters in `:core:data`. Write integration tests.
4. **Navigation Shell:** Set up Decompose root component with screen navigation (Focus, Clinic, Shop, Stats).
5. **Focus Feature:** Build the timer MVI loop (FocusState/FocusIntent/FocusViewModel). Implement `expect/actual` for lifecycle detection, WakeLock, and notifications.
6. **Shop Feature:** Build the virtual shop and custom rewards CRUD screens. Implement purchase transaction logic.
7. **Clinic Feature:** Build the clinic visualization screen that renders based on inventory items.
8. **Stats Feature:** Build session history and XP progress dashboard.
9. **Polish:** Animations, placeholder assets, edge case handling.
